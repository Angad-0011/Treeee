import { TreeRecord, TreeSpecies, TreeHealth } from '../types';
import { STORAGE_KEY } from '../constants';

export const saveTreesToStorage = (trees: TreeRecord[]) => {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(trees));
  } catch (e) {
    console.error('Failed to save to local storage', e);
  }
};

export const loadTreesFromStorage = (): TreeRecord[] => {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : [];
  } catch (e) {
    console.error('Failed to load from local storage', e);
    return [];
  }
};

export const generateCSV = (trees: TreeRecord[]): string => {
  const header = ['id', 'lat', 'lng', 'species', 'condition', 'dateAdded', 'notes'].join(',');
  const rows = trees.map(t => 
    [
      t.id,
      t.lat,
      t.lng,
      `"${t.species}"`,
      `"${t.condition}"`,
      `"${t.dateAdded}"`,
      `"${t.notes || ''}"`
    ].join(',')
  );
  return [header, ...rows].join('\n');
};

export const parseCSV = (csvText: string): TreeRecord[] => {
  const lines = csvText.trim().split('\n');
  if (lines.length < 2) return []; // Header only or empty

  // Simple CSV parser (assumes standard format generated by this app)
  // Skips header (index 0)
  const records: TreeRecord[] = [];
  
  for (let i = 1; i < lines.length; i++) {
    try {
      // Regex to handle basic quotes if present
      const parts = lines[i].match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g);
      if (!parts || parts.length < 6) continue;
      
      const clean = (s: string) => s.replace(/^"|"$/g, '');

      const record: TreeRecord = {
        id: parts[0] || crypto.randomUUID(),
        lat: parseFloat(parts[1]),
        lng: parseFloat(parts[2]),
        species: clean(parts[3]) as TreeSpecies,
        condition: clean(parts[4]) as TreeHealth,
        dateAdded: clean(parts[5]),
        notes: parts[6] ? clean(parts[6]) : '',
      };
      
      if (!isNaN(record.lat) && !isNaN(record.lng)) {
        records.push(record);
      }
    } catch (e) {
      console.warn('Skipping invalid row', i, e);
    }
  }
  return records;
};

export const downloadFile = (content: string, filename: string, mimeType: string) => {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};